#include"zuckey.h"
#define DECPOW31 0x7fffffff              //2^31-1
#define HOFHEX   0xffff0000
#define LOFHEX   0x0000ffff

int cycleLeft(unsigned int x, int j) {
	return (x << j) | (x >> (32 - j));
}

struct sBox {
	unsigned int s0[16][16];
	unsigned int s1[16][16];
}sbox = { {
0x3E,0x72,0x5B,0x47,0xCA,0xE0,0x00,0x33,0x04,0xD1,0x54,0x98,0x09,0xB9,0x6D,0xCB,
0x7B,0x1B,0xF9,0x32,0xAF,0x9D,0x6A,0xA5,0xB8,0x2D,0xFC,0x1D,0x08,0x53,0x03,0x90,
0x4D,0x4E,0x84,0x99,0xE4,0xCE,0xD9,0x91,0xDD,0xB6,0x85,0x48,0x8B,0x29,0x6E,0xAC,
0xCD,0xC1,0xF8,0x1E,0x73,0x43,0x69,0xC6,0xB5,0xBD,0xFD,0x39,0x63,0x20,0xD4,0x38,
0x76,0x7D,0xB2,0xA7,0xCF,0xED,0x57,0xC5,0xF3,0x2C,0xBB,0x14,0x21,0x06,0x55,0x9B,
0xE3,0xEF,0x5E,0x31,0x4F,0x7F,0x5A,0xA4,0x0D,0x82,0x51,0x49,0x5F,0xBA,0x58,0x1C,
0x4A,0x16,0xD5,0x17,0xA8,0x92,0x24,0x1F,0x8C,0xFF,0xD8,0xAE,0x2E,0x01,0xD3,0xAD,
0x3B,0x4B,0xDA,0x46,0xEB,0xC9,0xDE,0x9A,0x8F,0x87,0xD7,0x3A,0x80,0x6F,0x2F,0xC8,
0xB1,0xB4,0x37,0xF7,0x0A,0x22,0x13,0x28,0x7C,0xCC,0x3C,0x89,0xC7,0xC3,0x96,0x56,
0x07,0xBF,0x7E,0xF0,0x0B,0x2B,0x97,0x52,0x35,0x41,0x79,0x61,0xA6,0x4C,0x10,0xFE,
0xBC,0x26,0x95,0x88,0x8A,0xB0,0xA3,0xFB,0xC0,0x18,0x94,0xF2,0xE1,0xE5,0xE9,0x5D,
0xD0,0xDC,0x11,0x66,0x64,0x5C,0xEC,0x59,0x42,0x75,0x12,0xF5,0x74,0x9C,0xAA,0x23,
0x0E,0x86,0xAB,0xBE,0x2A,0x02,0xE7,0x67,0xE6,0x44,0xA2,0x6C,0xC2,0x93,0x9F,0xF1,
0xF6,0xFA,0x36,0xD2,0x50,0x68,0x9E,0x62,0x71,0x15,0x3D,0xD6,0x40,0xC4,0xE2,0x0F,
0x8E,0x83,0x77,0x6B,0x25,0x05,0x3F,0x0C,0x30,0xEA,0x70,0xB7,0xA1,0xE8,0xA9,0x65,
0x8D,0x27,0x1A,0xDB,0x81,0xB3,0xA0,0xF4,0x45,0x7A,0x19,0xDF,0xEE,0x78,0x34,0x60,
	},{
0x55,0xC2,0x63,0x71,0x3B,0xC8,0x47,0x86,0x9F,0x3C,0xDA,0x5B,0x29,0xAA,0xFD,0x77,
0x8C,0xC5,0x94,0x0C,0xA6,0x1A,0x13,0x00,0xE3,0xA8,0x16,0x72,0x40,0xF9,0xF8,0x42,
0x44,0x26,0x68,0x96,0x81,0xD9,0x45,0x3E,0x10,0x76,0xC6,0xA7,0x8B,0x39,0x43,0xE1,
0x3A,0xB5,0x56,0x2A,0xC0,0x6D,0xB3,0x05,0x22,0x66,0xBF,0xDC,0x0B,0xFA,0x62,0x48,
0xDD,0x20,0x11,0x06,0x36,0xC9,0xC1,0xCF,0xF6,0x27,0x52,0xBB,0x69,0xF5,0xD4,0x87,
0x7F,0x84,0x4C,0xD2,0x9C,0x57,0xA4,0xBC,0x4F,0x9A,0xDF,0xFE,0xD6,0x8D,0x7A,0xEB,
0x2B,0x53,0xD8,0x5C,0xA1,0x14,0x17,0xFB,0x23,0xD5,0x7D,0x30,0x67,0x73,0x08,0x09,
0xEE,0xB7,0x70,0x3F,0x61,0xB2,0x19,0x8E,0x4E,0xE5,0x4B,0x93,0x8F,0x5D,0xDB,0xA9,
0xAD,0xF1,0xAE,0x2E,0xCB,0x0D,0xFC,0xF4,0x2D,0x46,0x6E,0x1D,0x97,0xE8,0xD1,0xE9,
0x4D,0x37,0xA5,0x75,0x5E,0x83,0x9E,0xAB,0x82,0x9D,0xB9,0x1C,0xE0,0xCD,0x49,0x89,
0x01,0xB6,0xBD,0x58,0x24,0xA2,0x5F,0x38,0x78,0x99,0x15,0x90,0x50,0xB8,0x95,0xE4,
0xD0,0x91,0xC7,0xCE,0xED,0x0F,0xB4,0x6F,0xA0,0xCC,0xF0,0x02,0x4A,0x79,0xC3,0xDE,
0xA3,0xEF,0xEA,0x51,0xE6,0x6B,0x18,0xEC,0x1B,0x2C,0x80,0xF7,0x74,0xE7,0xFF,0x21,
0x5A,0x6A,0x54,0x1E,0x41,0x31,0x92,0x35,0xC4,0x33,0x07,0x0A,0xBA,0x7E,0x0E,0x34,
0x88,0xB1,0x98,0x7C,0xF3,0x3D,0x60,0x6C,0x7B,0xCA,0xD3,0x1F,0x32,0x65,0x04,0x28,
0x64,0xBE,0x85,0x9B,0x2F,0x59,0x8A,0xD7,0xB0,0x25,0xAC,0xAF,0x12,0x03,0xE2,0xF2,
	} };                                                        //全局sbox


static const unsigned int D[16] = {
	0x44d7,0x26bc,0x626b,0x135e,0x5789,0x35e2,0x7135,0x09af,0x4d78,0x2f13,0x6bc4,0x1af1,0x5e26,0x3c4d,0x789a,0x47ac
};

typedef enum LFSRARG {
	LFSR_INTI,
	LFSR_WORKING
}LFSRARG;

void move(unsigned int s[]) {                        //移动
	unsigned int i;
	for (i = 0; i <15; i++) {
		s[i] = s[i+1];
	}
}

unsigned int maxH(unsigned int s[],unsigned int u, LFSRARG MODE) {   //求最高位
	unsigned int s16;
	unsigned long long int v;
	v = ((unsigned long long int)s[15] * (1 << 15) + (unsigned long long int)s[13] * (1 << 17)
		+ (unsigned long long int)s[10] * (1 << 21) + (unsigned long long int)s[4] * (1 << 20)
		+ (unsigned long long int)s[0] * ((1 << 8) + 1)) % DECPOW31; //32相乘不超过64，long long mod或者long mod +
	if (MODE ==LFSR_INTI)
		s16 = (u + v)%DECPOW31;
	else
		s16 = v;
	if (s16 == 0)
		s16 = DECPOW31;
	return s16;
}

typedef enum LINETRANS
{
	L1, L2
}LINETRANS;


unsigned int SBOX(unsigned int index) {
	Byte* c = (Byte*)&index;
	c[3] = sbox.s0[((unsigned int)c[3] & 0xf0)>>4][(unsigned int)c[3] & 0xf];       //高四位和低四位
	c[2] = sbox.s1[((unsigned int)c[2] & 0xf0)>>4][(unsigned int)c[2] & 0xf];
	c[1] = sbox.s0[((unsigned int)c[1] & 0xf0)>>4][(unsigned int)c[1] & 0xf];
	c[0] = sbox.s1[((unsigned int)c[0] & 0xf0)>>4][(unsigned int)c[0] & 0xf];
	return index;
}

unsigned int LineTrans(unsigned int x, LINETRANS MODE) {
	if (MODE == L1)
		return x ^ cycleLeft(x , 2) ^ cycleLeft(x , 10) ^ cycleLeft(x, 18) ^ cycleLeft(x, 24); //循环移位
	else
		return x ^ cycleLeft(x, 8) ^ cycleLeft(x, 14) ^ cycleLeft(x, 22) ^ cycleLeft(x, 30);
}

void LFSR(unsigned int s[],unsigned int u, LFSRARG MODE) {         //LFSR
	unsigned int s16 = maxH(s, u, MODE);
	move(s);
	s[15] = s16;
}

void BITRECOMBINE(unsigned int s[], unsigned int x[]) {                    //bit重组
	x[0] = (s[15]<<1 & HOFHEX) + (s[14] & LOFHEX);           //除了x【0】外都是先低后高,所以需要移位,由于需要组成32位的字，所以需要移位
	x[1] = ((s[11] & LOFHEX) << 16) + ((s[9] << 1 & HOFHEX) >> 16);
	x[2] = ((s[7] & LOFHEX) << 16) + ((s[5] << 1 & HOFHEX) >> 16);
	x[3] = ((s[2] & LOFHEX) << 16) + ((s[0] << 1 & HOFHEX) >> 16);
}

unsigned int NOLINETRANS(unsigned int x[], unsigned int w[], unsigned int r[]) {                          //非线性变换F
	unsigned int rw = (x[0] ^ r[0]) + r[1];
	w[0] = x[1] + r[0];
	w[1] = x[2] ^ r[1];
	r[0] = SBOX(LineTrans( ((w[0] & LOFHEX) << 16) + ((w[1] & HOFHEX) >> 16), L1));
	r[1] = SBOX(LineTrans( ((w[1] & LOFHEX) << 16) + ((w[0] & HOFHEX) >> 16), L2));
	return rw;                //算法w
}

bool zuc_loadKey(ZUC_DATA* data, const Byte k[],const Byte iv[]) {
	unsigned int i = 0, w = 0;
	for (i = 0; i < 16; i++) {
		data->s[i] = ((unsigned int)(k[i]) << 23) +  (D[i] << 8) + (unsigned int)iv[i];  //拼接8+15+8  注意直接移位byte会丢失数据
	}                                                                                             //tip：使用无符号避免负数会转化补1
	for (i = 0; i < 32; i++) {
		BITRECOMBINE(data->s, data->x);
		w = NOLINETRANS(data->x, data->w, data->r);
		LFSR(data->s, w >> 1, LFSR_INTI);
	}
	return true;
}

unsigned int zuc_getKey(ZUC_DATA *data) {
	unsigned int w = 0;
	BITRECOMBINE(data->s, data->x);
	w = NOLINETRANS(data->x, data->w, data->r);
	LFSR(data->s, 0, LFSR_WORKING);                                 //工作模式不再启用w（u）
	return w ^ data->x[3];
}

